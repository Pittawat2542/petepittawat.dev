---
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import Header from '../components/Header.astro';
import ScrollTop from '../components/ScrollTop.astro';


const { title, description, image, type, publishedTime, tags } = Astro.props as {
  title: string;
  description: string;
  image?: string;
  type?: 'website' | 'article';
  publishedTime?: string;
  tags?: string[];
};
const ogImagePath = image ?? '/home-og-image.jpeg';
const ogImage = Astro.site
  ? new URL(ogImagePath, Astro.site).href
  : ogImagePath;
---

<!doctype html>
<html lang='en' style="background:#111827;color:#F9FAFB;color-scheme: dark;">
	<head>
		<BaseHead title={title} description={description} image={ogImage} type={type} publishedTime={publishedTime} tags={tags} />
		<slot name="head" />
		<link rel='sitemap' href='/sitemap-index.xml' />
		<!-- Preload critical resources -->
		<link rel="preload" href="/favicon.svg" as="image" type="image/svg+xml" />
	</head>

        <body>
                <Header />
                <main id="main-content" class='px-6 md:px-10 mx-auto pt-28 mb-12 max-w-screen-lg md:max-w-screen-xl'>
                        <slot />
                </main>
                <Footer />
                <ScrollTop />
                <script>
                  // Performance optimized initialization
                  (function() {
                    // Reveal-on-scroll for elements with `.reveal` class - optimized with RAF
                    const io = new IntersectionObserver(
                      (entries) => {
                        for (const e of entries) {
                          if (e.isIntersecting) {
                            requestAnimationFrame(() => {
                              e.target.classList.add('reveal-visible');
                            });
                            io.unobserve(e.target); // Stop observing once revealed
                          }
                        }
                      },
                      { rootMargin: '0px 0px -5% 0px', threshold: 0.05 }
                    );
                    
                    // Batch DOM queries for better performance
                    const initReveal = () => {
                      const elements = document.querySelectorAll('.reveal');
                      elements.forEach(el => io.observe(el));
                    };

                    // Security: ensure rel for target=_blank links - optimized
                    const fixExternalRel = () => {
                      try {
                        const links = document.querySelectorAll('a[target="_blank"]');
                        
                        links.forEach((a) => {
                          const current = (a.getAttribute('rel') || '').split(/\s+/).filter(Boolean);
                          if (!current.includes('noopener')) current.push('noopener');
                          if (!current.includes('noreferrer')) current.push('noreferrer');
                          a.setAttribute('rel', current.join(' '));
                        });
                      } catch (e) {
                        console.warn('Failed to fix external link rels:', e);
                      }
                    };
                    
                    // Optimize initialization timing
                    if (document.readyState === 'loading') {
                      document.addEventListener('DOMContentLoaded', () => {
                        requestAnimationFrame(() => {
                          initReveal();
                          fixExternalRel();
                        });
                      });
                    } else {
                      requestAnimationFrame(() => {
                        initReveal();
                        fixExternalRel();
                      });
                    }
                  })();
                </script>
        </body>
</html>
